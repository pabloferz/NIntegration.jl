"""    nintegrate(f, xmin::NTuple{N}, xmax::NTuple{N};
               reltol = 1e-6, abstol = 1e-12,
               maxevals = 1000000)

Approximate numerical integration routine based on an adaptive algorithm
[^BEG1991].

- `f` is the integrand.
- `xmin` and `xmax` are tuples specifiying the boundaries of the integration
  domain.
- `reltol`, `abstol` and `maxevals` are optional keyword arguments that
  determine the termination criteria.

Returns a tuple of the approximated integral, error estimate, number of
functions evaluations and an object of type `Regions` (a set of subregions in
which the integration domain was subdivided).

[^BEG1991]: J. Berntsen, T. O. Espelid, A. Genz, "An Adaptive Algorithm for the Approximate Calculation of Multiple Integrals," ACM Trans. Math. Soft., 17 (4), 437-451 (1991).
"""
function nintegrate{F,N}(f::F, xmin::NTuple{N}, xmax::NTuple{N};
                         reltol::Float64 = 1e-6, abstol::Float64 = eps(),
                         maxevals::Int = 1000000)
    # find the center and half-widths of the whole integration domain
    tx = map((a, b) -> (a + b) / 2, xmin, xmax)
    th = map((a, b) -> (b - a) / 2, xmin, xmax)
    T = Base.promote_typeof(tx..., th...)
    x, h = map(T, tx), map(T, th)
    r = Region(integral_type(f, x), x, h)

    # apply the integration rule to the whole domain
    # and initiate the regions heap
    P = zeros(MMatrix{2,3})
    I, E = apply_rule!(f, r, P)
    regions = binary_maxheap(typeof(r))
    push!(regions, r)
    evals = L = L₁₁

    # adaptively subdivide regions until the termination criteria is met
    while evals < maxevals && E > abs(I) * reltol && E > abstol
        r = pop!(regions)
        r₁, r₂ = divide(r)
        I₁, E₁ = apply_rule!(f, r₁, P)
        I₂, E₂ = apply_rule!(f, r₂, P)
        ΔI, ΔE = error_estimates!(r₁, r₂, r, I₁, I₂, E₁, E₂)

        push!(regions, r₁)
        push!(regions, r₂)

        evals += 2L
        I += ΔI
        E += ΔE
    end

    return I, E, evals, Regions(regions.valtree)
end

"""    nintegrate(f, regions::Regions)

Approximate numerical integration routine that takes the integrand `f` and a
`Regions` object which is a subdivision of the integration domain.
"""
nintegrate{F}(f::F, regions::Regions) = nintegrate(f, regions.v)
function nintegrate{F,N,T,R}(f::F, regions::Vector{Region{N,T,R}})
    P = zeros(MMatrix{2,3})
    I = zero(R)
    for r in regions
        I += apply_rule(f, r, P)
    end
    return I
end

function divide(r::Region)
    i = r.axis.x
    r₁ = deepcopy(r)
    r₂ = deepcopy(r)
    r₁.x[i] -= r.h[i] / 2
    r₂.x[i] += r.h[i] / 2
    r₁.h[i] = r₂.h[i] = r.h[i] / 2
    return r₁, r₂
end

function apply_rule!{F}(f::F, r::Region, P)
    I, N₁, N₂, N₃, N₄, fu, fuα₁, fuα₂ = _apply_rule(f, r, P)
    r.axis.x = choose_axis(r.h, fu, fuα₁, fuα₂)
    E = compute_error(N₁, N₂, N₃, N₄)
    V = prod(r.h)
    I = r.I.x = V * I
    E = r.E.x = 8V * E
    return I, E
end

@inline function _apply_rule{F,T,R}(f::F, r::Region{3,T,R}, P)
    x₁, x₂, x₃ = r.x
    h₁, h₂, h₃ = r.h

    fu = f(x₁, x₂, x₃)
    I = p₀[1] * fu
    N₁ = p₀[2] * fu
    N₂ = p₀[3] * fu
    N₃ = p₀[4] * fu
    N₄ = p₀[5] * fu

    # points generated by (αᵢ, 0, 0, 0, ...)
    u = α₁
    w, w₁, w₂, w₃, w₄ = wa[1]

    uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
    P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
    P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

    fuα₁ = ( f(P[1], x₂, x₃) + f(P[2], x₂, x₃) ,
             f(x₁, P[3], x₃) + f(x₁, P[4], x₃) ,
             f(x₁, x₂, P[5]) + f(x₁, x₂, P[6]) )

    s = fuα₁[1] + fuα₁[2] + fuα₁[3]

    I += w * s
    N₁ += w₁ * s
    N₂ += w₂ * s
    N₃ += w₃ * s
    N₄ += w₄ * s

    u = α₂
    w, w₁, w₂, w₃, w₄ = wa[2]

    uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
    P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
    P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

    fuα₂ = ( f(P[1], x₂, x₃) + f(P[2], x₂, x₃) ,
             f(x₁, P[3], x₃) + f(x₁, P[4], x₃) ,
             f(x₁, x₂, P[5]) + f(x₁, x₂, P[6]) )

    s = fuα₂[1] + fuα₂[2] + fuα₂[3]

    I += w * s
    N₁ += w₁ * s
    N₂ += w₂ * s
    N₃ += w₃ * s
    N₄ += w₄ * s

    @inbounds for i = 3:length(α)
        u = α[i]
        w, w₁, w₂, w₃, w₄ = wa[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], x₂, x₃) + f(x₁, P[3], x₃) + f(x₁, x₂, P[5]) +
            f(P[2], x₂, x₃) + f(x₁, P[4], x₃) + f(x₁, x₂, P[6])

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    # points generated by (βᵢ, βᵢ, 0, 0, ...)
    @inbounds for i = 1:length(β)
        u = β[i]
        w, w₁, w₂, w₃, w₄ = wb[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], P[3], x₃) + f(P[1], x₂, P[5]) + f(x₁, P[3], P[5]) +
            f(P[1], P[4], x₃) + f(P[1], x₂, P[6]) + f(x₁, P[3], P[6]) +
            f(P[2], P[3], x₃) + f(P[2], x₂, P[5]) + f(x₁, P[4], P[5]) +
            f(P[2], P[4], x₃) + f(P[2], x₂, P[6]) + f(x₁, P[4], P[6])

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    # points generated by (ɛᵢ, ɛᵢ, ɛᵢ, 0, ...)
    @inbounds for i = 1:length(ɛ)
        u = ɛ[i]
        w, w₁, w₂, w₃, w₄ = wd[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    # points generated by (ζᵢ, ζᵢ, ηᵢ, 0, ...)
    @inbounds for i = 1:length(ζ)
        u, v = ζ[i], η[i]
        w, w₁, w₂, w₃, w₄ = we[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, v * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₂, uh₃ = v * h₂, u * h₃
        P[3], P[5] = x₂ + uh₂, x₃ + uh₃
        P[4], P[6] = x₂ - uh₂, x₃ - uh₃

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₁, uh₂ = v * h₁, u * h₂
        P[1], P[3] = x₁ + uh₁, x₂ + uh₂
        P[2], P[4] = x₁ - uh₁, x₂ - uh₂

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    return I, N₁, N₂, N₃, N₄, fu, fuα₁, fuα₂
end

function apply_rule{F,T,R}(f::F, r::Region{3,T,R}, P)
    x₁, x₂, x₃ = r.x
    h₁, h₂, h₃ = r.h

    fu = f(x₁, x₂, x₃)
    I = p₀[1] * fu

    # points generated by (αᵢ, 0, 0, 0, ...)
    @inbounds for i = 1:length(α)
        u = α[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], x₂, x₃) + f(x₁, P[3], x₃) + f(x₁, x₂, P[5]) +
            f(P[2], x₂, x₃) + f(x₁, P[4], x₃) + f(x₁, x₂, P[6])

        I += wa[i][1] * s
    end

    # points generated by (βᵢ, βᵢ, 0, 0, ...)
    @inbounds for i = 1:length(β)
        u = β[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], P[3], x₃) + f(P[1], x₂, P[5]) + f(x₁, P[3], P[5]) +
            f(P[1], P[4], x₃) + f(P[1], x₂, P[6]) + f(x₁, P[3], P[6]) +
            f(P[2], P[3], x₃) + f(P[2], x₂, P[5]) + f(x₁, P[4], P[5]) +
            f(P[2], P[4], x₃) + f(P[2], x₂, P[6]) + f(x₁, P[4], P[6])

        I += wb[i][1] * s
    end

    # points generated by (ɛᵢ, ɛᵢ, ɛᵢ, 0, ...)
    @inbounds for i = 1:length(ɛ)
        u = ɛ[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += wd[i][1] * s
    end

    # points generated by (ζᵢ, ζᵢ, ηᵢ, 0, ...)
    @inbounds for i = 1:length(ζ)
        u, v = ζ[i], η[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, v * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₂, uh₃ = v * h₂, u * h₃
        P[3], P[5] = x₂ + uh₂, x₃ + uh₃
        P[4], P[6] = x₂ - uh₂, x₃ - uh₃

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₁, uh₂ = v * h₁, u * h₂
        P[1], P[3] = x₁ + uh₁, x₂ + uh₂
        P[2], P[4] = x₁ - uh₁, x₂ - uh₂

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += we[i][1] * s
    end

    return I * (h₁ * h₂ * h₃)
end

function choose_axis(h, fu, fuα₁, fuα₂)
    r = (α₁ / α₂)^2
    fc = 2fu * (1 - r)
    Df₁ = chop(abs(fuα₁[1] - r * fuα₂[1] - fc))
    Df₂ = chop(abs(fuα₁[2] - r * fuα₂[2] - fc))
    Df₃ = chop(abs(fuα₁[3] - r * fuα₂[3] - fc))

    if Df₁ == Df₂ == Df₃
        return indmax(h)
    else
        return indmax((Df₁, Df₂, Df₃))
    end
end

function compute_error(N₁, N₂, N₃, N₄)
    N₁⃰ = N₂⃰ = N₃⃰ = zero(N₁)

    @inbounds for i = 1:length(s₁)
        N₁⃰ = max(N₁⃰, abs(μ₁[i] * N₁ + N₂) * s₁[i])
        N₂⃰ = max(N₂⃰, abs(μ₂[i] * N₂ + N₃) * s₂[i])
        N₃⃰ = max(N₃⃰, abs(μ₃[i] * N₃ + N₄) * s₃[i])
    end
    @inbounds for i = length(s₁)+1:length(s₃)
        N₂⃰ = max(N₂⃰, abs(μ₂[i] * N₂ + N₃) * s₂[i])
        N₃⃰ = max(N₃⃰, abs(μ₃[i] * N₃ + N₄) * s₃[i])
    end
    @inbounds for i = length(s₃)+1:length(s₂)
        N₂⃰ = max(N₂⃰, abs(μ₂[i] * N₂ + N₃) * s₂[i])
    end

    if c[1] * N₁⃰ ≤ N₂⃰ && c[2] * N₂⃰ ≤ N₃⃰
        return c[3] * N₁⃰
    else
        return c[4] * max(N₁⃰, N₂⃰, N₃⃰)
    end
end

function error_estimates!(r₁, r₂, r, I₁, I₂, E₁, E₂)
    ΔI = I₁ + I₂ - r.I.x

    E₂⃰ = abs(ΔI)
    if (E₁⃰ = E₁ + E₂) > 0
        E₁ += c[5] * E₁ * E₂⃰ / E₁⃰
        E₂ += c[5] * E₂ * E₂⃰ / E₁⃰
    end
    E₁ += c[6] * E₂⃰
    E₂ += c[6] * E₂⃰

    ΔE = E₁ + E₂ - r.E.x
    r₁.E.x = E₁
    r₂.E.x = E₂

    return ΔI, ΔE
end
