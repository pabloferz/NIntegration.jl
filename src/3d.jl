function _apply_rule{F,T,R}(f::F, r::Region{3,T,R}, P::MMatrix{2,3})
    x₁, x₂, x₃ = r.x
    h₁, h₂, h₃ = r.h

    fu = f(x₁, x₂, x₃)
    I = p₀[1] * fu
    N₁ = p₀[2] * fu
    N₂ = p₀[3] * fu
    N₃ = p₀[4] * fu
    N₄ = p₀[5] * fu

    # points generated by (αᵢ, 0, 0, 0, ...)
    u = α₁
    w, w₁, w₂, w₃, w₄ = wa[1]

    uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
    P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
    P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

    fuα₁ = ( f(P[1], x₂, x₃) + f(P[2], x₂, x₃) ,
             f(x₁, P[3], x₃) + f(x₁, P[4], x₃) ,
             f(x₁, x₂, P[5]) + f(x₁, x₂, P[6]) )

    s = fuα₁[1] + fuα₁[2] + fuα₁[3]

    I += w * s
    N₁ += w₁ * s
    N₂ += w₂ * s
    N₃ += w₃ * s
    N₄ += w₄ * s

    u = α₂
    w, w₁, w₂, w₃, w₄ = wa[2]

    uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
    P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
    P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

    fuα₂ = ( f(P[1], x₂, x₃) + f(P[2], x₂, x₃) ,
             f(x₁, P[3], x₃) + f(x₁, P[4], x₃) ,
             f(x₁, x₂, P[5]) + f(x₁, x₂, P[6]) )

    s = fuα₂[1] + fuα₂[2] + fuα₂[3]

    I += w * s
    N₁ += w₁ * s
    N₂ += w₂ * s
    N₃ += w₃ * s
    N₄ += w₄ * s

    @inbounds for i = 3:length(α)
        u = α[i]
        w, w₁, w₂, w₃, w₄ = wa[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], x₂, x₃) + f(x₁, P[3], x₃) + f(x₁, x₂, P[5]) +
            f(P[2], x₂, x₃) + f(x₁, P[4], x₃) + f(x₁, x₂, P[6])

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    # points generated by (βᵢ, βᵢ, 0, 0, ...)
    @inbounds for i = 1:length(β)
        u = β[i]
        w, w₁, w₂, w₃, w₄ = wb[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], P[3], x₃) + f(P[1], x₂, P[5]) + f(x₁, P[3], P[5]) +
            f(P[1], P[4], x₃) + f(P[1], x₂, P[6]) + f(x₁, P[3], P[6]) +
            f(P[2], P[3], x₃) + f(P[2], x₂, P[5]) + f(x₁, P[4], P[5]) +
            f(P[2], P[4], x₃) + f(P[2], x₂, P[6]) + f(x₁, P[4], P[6])

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    # points generated by (ɛᵢ, ɛᵢ, ɛᵢ, 0, ...)
    @inbounds for i = 1:length(ɛ)
        u = ɛ[i]
        w, w₁, w₂, w₃, w₄ = wd[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    # points generated by (ζᵢ, ζᵢ, ηᵢ, 0, ...)
    @inbounds for i = 1:length(ζ)
        u, v = ζ[i], η[i]
        w, w₁, w₂, w₃, w₄ = we[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, v * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₂, uh₃ = v * h₂, u * h₃
        P[3], P[5] = x₂ + uh₂, x₃ + uh₃
        P[4], P[6] = x₂ - uh₂, x₃ - uh₃

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₁, uh₂ = v * h₁, u * h₂
        P[1], P[3] = x₁ + uh₁, x₂ + uh₂
        P[2], P[4] = x₁ - uh₁, x₂ - uh₂

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += w * s
        N₁ += w₁ * s
        N₂ += w₂ * s
        N₃ += w₃ * s
        N₄ += w₄ * s
    end

    return I, N₁, N₂, N₃, N₄, fu, fuα₁, fuα₂
end

function apply_rule{F,T,R}(f::F, r::Region{3,T,R}, P::MMatrix{2,3})
    x₁, x₂, x₃ = r.x
    h₁, h₂, h₃ = r.h

    fu = f(x₁, x₂, x₃)
    I = p₀[1] * fu

    # points generated by (αᵢ, 0, 0, 0, ...)
    @inbounds for i = 1:length(α)
        u = α[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], x₂, x₃) + f(x₁, P[3], x₃) + f(x₁, x₂, P[5]) +
            f(P[2], x₂, x₃) + f(x₁, P[4], x₃) + f(x₁, x₂, P[6])

        I += wa[i][1] * s
    end

    # points generated by (βᵢ, βᵢ, 0, 0, ...)
    @inbounds for i = 1:length(β)
        u = β[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = f(P[1], P[3], x₃) + f(P[1], x₂, P[5]) + f(x₁, P[3], P[5]) +
            f(P[1], P[4], x₃) + f(P[1], x₂, P[6]) + f(x₁, P[3], P[6]) +
            f(P[2], P[3], x₃) + f(P[2], x₂, P[5]) + f(x₁, P[4], P[5]) +
            f(P[2], P[4], x₃) + f(P[2], x₂, P[6]) + f(x₁, P[4], P[6])

        I += wb[i][1] * s
    end

    # points generated by (ɛᵢ, ɛᵢ, ɛᵢ, 0, ...)
    @inbounds for i = 1:length(ɛ)
        u = ɛ[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += wd[i][1] * s
    end

    # points generated by (ζᵢ, ζᵢ, ηᵢ, 0, ...)
    @inbounds for i = 1:length(ζ)
        u, v = ζ[i], η[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, v * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        s = zero(R)
        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₂, uh₃ = v * h₂, u * h₃
        P[3], P[5] = x₂ + uh₂, x₃ + uh₃
        P[4], P[6] = x₂ - uh₂, x₃ - uh₃

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        uh₁, uh₂ = v * h₁, u * h₂
        P[1], P[3] = x₁ + uh₁, x₂ + uh₂
        P[2], P[4] = x₁ - uh₁, x₂ - uh₂

        for l = 1:2, m = 1:2, n = 1:2
            s += f(P[l, 1], P[m, 2], P[n, 3])
        end

        I += we[i][1] * s
    end

    return I * (h₁ * h₂ * h₃)
end

function weightedpoints!{F,T,R}(f::F, W::Vector{WPoint{3,T}},
                                r::Region{3,T,R}, P::MMatrix{2,3})
    x₁, x₂, x₃ = r.x
    h₁, h₂, h₃ = r.h

    V = h₁ * h₂ * h₃

    push!(W, f(V * p₀[1], (x₁, x₂, x₃)))

    # points generated by (αᵢ, 0, 0, 0, ...)
    @inbounds for i = 1:length(α)
        u = α[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        push!(W, f(V * wa[i][1], (P[1], x₂, x₃)))
        push!(W, f(V * wa[i][1], (P[2], x₂, x₃)))
        push!(W, f(V * wa[i][1], (x₁, P[3], x₃)))
        push!(W, f(V * wa[i][1], (x₁, P[4], x₃)))
        push!(W, f(V * wa[i][1], (x₁, x₂, P[5])))
        push!(W, f(V * wa[i][1], (x₁, x₂, P[6])))
    end

    # points generated by (βᵢ, βᵢ, 0, 0, ...)
    @inbounds for i = 1:length(β)
        u = β[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        push!(W, f(V * wb[i][1], (P[1], P[3], x₃)))
        push!(W, f(V * wb[i][1], (P[1], P[4], x₃)))
        push!(W, f(V * wb[i][1], (P[2], P[3], x₃)))
        push!(W, f(V * wb[i][1], (P[2], P[4], x₃)))
        push!(W, f(V * wb[i][1], (P[1], x₂, P[5])))
        push!(W, f(V * wb[i][1], (P[1], x₂, P[6])))
        push!(W, f(V * wb[i][1], (P[2], x₂, P[5])))
        push!(W, f(V * wb[i][1], (P[2], x₂, P[6])))
        push!(W, f(V * wb[i][1], (x₁, P[3], P[5])))
        push!(W, f(V * wb[i][1], (x₁, P[3], P[6])))
        push!(W, f(V * wb[i][1], (x₁, P[4], P[5])))
        push!(W, f(V * wb[i][1], (x₁, P[4], P[6])))
    end

    # points generated by (ɛᵢ, ɛᵢ, ɛᵢ, 0, ...)
    @inbounds for i = 1:length(ɛ)
        u = ɛ[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, u * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        for l = 1:2, m = 1:2, n = 1:2
            push!(W, f(V * wd[i][1], (P[l, 1], P[m, 2], P[n, 3])))
        end
    end

    # points generated by (ζᵢ, ζᵢ, ηᵢ, 0, ...)
    @inbounds for i = 1:length(ζ)
        u, v = ζ[i], η[i]

        uh₁, uh₂, uh₃ = u * h₁, u * h₂, v * h₃
        P[1], P[3], P[5] = x₁ + uh₁, x₂ + uh₂, x₃ + uh₃
        P[2], P[4], P[6] = x₁ - uh₁, x₂ - uh₂, x₃ - uh₃

        for l = 1:2, m = 1:2, n = 1:2
            push!(W, f(V * we[i][1], (P[l, 1], P[m, 2], P[n, 3])))
        end

        uh₂, uh₃ = v * h₂, u * h₃
        P[3], P[5] = x₂ + uh₂, x₃ + uh₃
        P[4], P[6] = x₂ - uh₂, x₃ - uh₃

        for l = 1:2, m = 1:2, n = 1:2
            push!(W, f(V * we[i][1], (P[l, 1], P[m, 2], P[n, 3])))
        end

        uh₁, uh₂ = v * h₁, u * h₂
        P[1], P[3] = x₁ + uh₁, x₂ + uh₂
        P[2], P[4] = x₁ - uh₁, x₂ - uh₂

        for l = 1:2, m = 1:2, n = 1:2
            push!(W, f(V * we[i][1], (P[l, 1], P[m, 2], P[n, 3])))
        end
    end

    return nothing
end
